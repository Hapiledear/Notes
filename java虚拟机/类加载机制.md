# 类加载机制
虚拟机将描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的java类型，称之为虚拟机的类加载机制。
java语言的特性之一，便是可以动态扩展。例如，在编写一个接口时，在运行时从网络或本地加载一个二进制流来作为程序代码的一部分，继续运行。
约定：
- 本文所提到的“类”，如无特别说名，则有类和接口两种可能性。
- “Class文件”，指的是以任何形式存在的一串二进制流。


## 类加载的时机
整个类的生命周期包括：**加载、验证、准备、解析、初始化、使用、卸载**7个阶段。
![类的生命周期图]()
加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始，而解析阶段则不一定：在某些情况下可以在初始化之后再开始。这些阶段通常是互相交叉的混合式进行，通常会在一个阶段的过程中调用、激活另外一个阶段。
何时进入加载阶段，虚拟机可以自由把控。但对于初始化阶段，则有严格的5种情况，必须立即对类进行“初始化”：
1. 遇到new、getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。最常见的java代码场景是:使用`new`进行实例化对象；读取或设置一个类的被`final`修饰的字段时；调用一个类的静态方法时。
2. 使用java.lang.reflect包的方法对类进行反射调用时。
3. 初始化一个类时，发现其父类还没有进行过初始化，先触发其父类的初始化。
4. 虚拟机启动时，需指定一个要执行的主类(main方法所在的类)，虚拟机先初始化这个主类。
5. 使用JDK1.7的动态语言支持时，MethodHandle最后的解析结果是REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，且这个方法句柄所对应的类没有进行过初始化。

上述5种场景中的行为称之为对一个类进行**主动引用**，除此之外，所有引用类的方式都不会触发初始化，称为**被动引用**。
接口的初始化过程第3种情况与类稍有不同：一个接口在初始化时，并不要求其父接口全部完成初始化，只有真正使用到的父接口才会初始化。
## 类加载的过程
### 加载
在加载阶段，需要完成以下3件事情：
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据访问入口

对于第1点，并未明确指明二进制字节流要从何获取、怎么获取。具有十分大的开放性，也诞生了许多举足轻重的Java技术，如：
- 从zip包中读取。最终成为日后的jar,ear,war格式的基础。
- 从网络中获取，典型应用就是Applet.
- 运行时计算生成。动态代理技术。
- 由其他文件生成。JPS文件生成对应的Class类。
- 从数据库中读取。

### 验证
验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
从整体上看，验证阶段大致会完成4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。
1. 文件格式验证
验证字节流是否符合Class文件格式的规范，且能被当前版本的虚拟机处理。
2. 元数据验证
对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。
3. 字节码验证
通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在对元数据信息进行校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
4. 符号引用验证
发生在解析阶段，将符号引用转化为直接引用时。符号引用验证可以看做是对类自身以外的信息进行匹配性校验。
### 准备
准备阶段是**正式为类变量分配内存并设置类变量初始值**的阶段，这些变量所使用的内存都将在方法区中进行分配。
需要注意的是，被`final`修饰的`public static final int value = 123`，在这个阶段初始化的值为123.
而`public static int value = 123`在此阶段的初始值为0，需等到运行`<clinit>()`时才将123赋值给value。
### 解析
解析阶段是**虚拟机将常量池内的符号引用替换为直接引用**的过程，符号引用在Class文件中以`CONSTANT_xxx_info`等类型的常量出现(xxx可以替换为Class,Fieldref.Methodref等)。
- **符号引用**以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。和虚拟机实现的内存布局无关。
- **直接引用**可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。和虚拟机实现的内存布局相关。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。
### 初始化
初始化阶段是**执行类构造器`<clinit>()`方法的过程。**
- `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块`static{}`中的语句合并产生的。
```
public class A{
	static{
		i = 0;	//给变量赋值可以正常编译通过
		System.out.print(i);//提示“非法向前引用”
	}
	static int i = 1;
}
```
- `<clinit>()`方法与类的构造函数(`<init>()`方法)不同，它不需要显式地调用父类构造器，虚拟机会保证在子类执行cl方法前，父类的cl方法已经执行完毕。
- 由于父类的cl方法先执行，也就意味着**父类中定义的静态语句块要优先于子类的变量赋值操作。**
- 如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成cl方法。
- 接口中不能使用静态语句块，但仍有变量初始化的赋值操作，因此会生成cl方法。但只有当父接口中定义的变量使用时，父接口才会初始化。
- 虚拟机会保证一个类的cl方法在多线程环境中被正确的加锁、同步。

## [类加载器](http://www.cnblogs.com/ityouknow/p/5603287.html)
在类加载阶段中“通过一个类的全限定名来获取描述此类的二进制字节流”这一动作的代码模块称之为“类加载器”。而这些代码全由虚拟机外部，即应用程序自己实现。理解类加载和核心，便是理解OSGi的实现。
从Java开发人员的角度看，类加载器分为三类，使用双亲委派模型进行派遣分发：
- 启动类加载器:负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。
- 扩展类加载器:该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。
- 应用程序类加载器：该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

![层次关系图]()